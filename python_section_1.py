# -*- coding: utf-8 -*-
"""python_section_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17dVYZM-pigLNyEvax215PqFvvejtj9yY

Question 1: Reverse List by N Elements
"""

def reverse_by_n(lst, n):
    result = []
    for i in range(0, len(lst), n):
        group = lst[i:i+n]  # Take the current group of n elements
        reversed_group = []
        for j in range(len(group) - 1, -1, -1):
            reversed_group.append(group[j])  # Manually reverse
        result.extend(reversed_group)  # Append the reversed group
    return result

"""Question 2: Lists & Dictionaries"""

def group_by_length(lst):
    result = {}
    for word in lst:
        length = len(word)
        if length not in result:
            result[length] = []
        result[length].append(word)
    return dict(sorted(result.items()))  # Sort by length

"""Question 3: Flatten a Nested Dictionary"""

def flatten_dict(d, parent_key='', sep='.'):
    items = []
    for k, v in d.items():
        new_key = f'{parent_key}{sep}{k}' if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep).items())
        elif isinstance(v, list):
            for i, val in enumerate(v):
                items.extend(flatten_dict({f'[{i}]': val}, new_key, sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

"""Question 4: Generate Unique Permutations"""

from itertools import permutations

def unique_permutations(lst):
    return list(map(list, set(permutations(lst))))

"""Question 5: Find All Dates in a Text"""

import re

def find_all_dates(text):
    pattern = r'(\d{2}-\d{2}-\d{4})|(\d{2}/\d{2}/\d{4})|(\d{4}\.\d{2}\.\d{2})'
    matches = re.findall(pattern, text)
    # Flatten the results from findall and filter empty matches
    return [date for group in matches for date in group if date]

"""Question 6: Decode Polyline, Convert to DataFrame with Distances"""

import pandas as pd
from haversine import haversine
import polyline

def decode_polyline_to_df(polyline_str):
    coordinates = polyline.decode(polyline_str)
    df = pd.DataFrame(coordinates, columns=['latitude', 'longitude'])
    df['distance'] = 0.0

    for i in range(1, len(df)):
        coord1 = (df.loc[i-1, 'latitude'], df.loc[i-1, 'longitude'])
        coord2 = (df.loc[i, 'latitude'], df.loc[i, 'longitude'])
        df.loc[i, 'distance'] = haversine(coord1, coord2) * 1000  # distance in meters

    return df

"""Question 7: Matrix Rotation and Transformation"""

import numpy as np

def rotate_and_transform(matrix):
    n = len(matrix)
    rotated_matrix = np.rot90(np.array(matrix), -1).tolist()  # Rotate 90 degrees clockwise
    final_matrix = []

    for i in range(n):
        row_sum = sum(rotated_matrix[i])
        final_row = []
        for j in range(n):
            col_sum = sum(rotated_matrix[k][j] for k in range(n))
            final_row.append(row_sum + col_sum - 2 * rotated_matrix[i][j])  # Exclude the element itself
        final_matrix.append(final_row)

    return final_matrix